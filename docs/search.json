[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Colours of the Taylor Swift Universe",
    "section": "",
    "text": "Taylor Swift’s Eras Tour Color-Music Relationships\nThis is a short collection of visualization and Rstats exercises exploring Taylor Swift’s use of colour in her Eras tour outfits and her lyrics!"
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "1  Data wrangling",
    "section": "",
    "text": "Note\n\n\n\nAll data paths are relative to the root of the GitHub repository\n\n\n\n## packages \nrequire(tidyverse)\nrequire(readxl)\n\n\n## reading in data\nsurpriseSongsDressColours <-  readxl::read_excel(\"raw_data/surprise_songs.xlsx\", sheet = \"List\")\nsurpriseSongsDressColours$Date <- as.Date(surpriseSongsDressColours$Date)\n## map hex colour to outfit\ndressColorMapping <- unique(surpriseSongsDressColours %>% select(DressName, ColourHex1))\ncolorPaletteDresses <- setNames(dressColorMapping$ColourHex1, dressColorMapping$DressName)\npathToDressColours <- \"dress_images/images_high_res/cropped/\"\n\n\n## Need only consider first element of each concerts as the\n## same outfit was worn for all surprise songs\n## for anyone concert\noneRowPerConcert <- surpriseSongsDressColours %>%\n    group_by(Date) %>%\n    arrange(Date, Order) %>% \n    slice(1) %>%\n    ungroup()\noneRowPerConcert\n\n# A tibble: 147 × 26\n   `Song title`         Mashups Mashup Mashup2 Guest City  State Country Stadium\n   <chr>                <chr>   <chr>  <chr>   <chr> <chr> <chr> <chr>   <chr>  \n 1 mirrorball           None    <NA>   <NA>    <NA>  Glen… Ariz… US      State …\n 2 this is me trying    None    <NA>   <NA>    <NA>  Glen… Ariz… US      State …\n 3 Our Song             None    <NA>   <NA>    <NA>  Las … Neva… US      Allegi…\n 4 cowboy like me       None    <NA>   <NA>    Marc… Las … Neva… US      Allegi…\n 5 Sad Beautiful Tragic None    <NA>   <NA>    <NA>  Arli… Texas US      AT&T   \n 6 Death By A Thousand… None    <NA>   <NA>    <NA>  Arli… Texas US      AT&T   \n 7 Speak Now            None    <NA>   <NA>    <NA>  Tampa Flor… US      Raymon…\n 8 The Great War        None    <NA>   <NA>    Aaro… Tampa Flor… US      Raymon…\n 9 mad woman            None    <NA>   <NA>    <NA>  Tampa Flor… US      Raymon…\n10 Wonderland           None    <NA>   <NA>    <NA>  Hous… Texas US      NRG    \n# ℹ 137 more rows\n# ℹ 17 more variables: Date <date>, DressName <chr>, Legs <chr>,\n#   Relationship <chr>, Start <dttm>, End <dttm>, Colour1 <chr>,\n#   ColourHex1 <chr>, ColourRGB1 <chr>, Colour2 <chr>, ColourHex2 <chr>,\n#   ColourRGB2 <chr>, `Night #` <dbl>, Order <dbl>, Instrument <chr>,\n#   `Special Annoucement` <chr>, Notes <chr>\n\n\n\n## map outfits to the corresponding images\noneRowPerConcert %>%\n    count(DressName) %>%\n    mutate(\n        percentage = n / sum(n) * 100,\n        imagePath = case_when(\n            DressName == \"Pink\" ~paste0(pathToDressColours, \"pink.jpg\"),\n            DressName == \"Green\" ~paste0(pathToDressColours, \"green.jpg\"),\n            DressName == \"Yellow\" ~paste0(pathToDressColours, \"yellow.jpg\"),\n            DressName == \"Blue\" ~paste0(pathToDressColours, \"blue.jpg\"),\n            DressName == \"Flamingo pink\" ~ paste0(pathToDressColours,\"flamingo_pink.jpg\"),\n            DressName == \"Ocean blue\" ~ paste0(pathToDressColours,\"ocean_blue.jpg\"),\n            DressName == \"Sunset orange\" ~ paste0(pathToDressColours,\"sunset_orange.jpg\"),\n            DressName == \"Cotton candy\" ~paste0(pathToDressColours, \"cotton_candy.jpg\"),\n            DressName == \"Blurple\" ~paste0(pathToDressColours, \"blurple.jpg\"),\n            DressName == \"Grapefruit\" ~ paste0(pathToDressColours,\"grapefruit.jpg\"),\n            DressName == \"Popsicle\" ~ paste0(pathToDressColours,\"popsicle.jpg\"),\n            TRUE ~ NA_character_\n        )) -> outfits\noutfits\n\n# A tibble: 11 × 4\n   DressName         n percentage imagePath                                     \n   <chr>         <int>      <dbl> <chr>                                         \n 1 Blue              9       6.12 dress_images/images_high_res/cropped/blue.jpg \n 2 Blurple           7       4.76 dress_images/images_high_res/cropped/blurple.…\n 3 Cotton candy      3       2.04 dress_images/images_high_res/cropped/cotton_c…\n 4 Flamingo pink    15      10.2  dress_images/images_high_res/cropped/flamingo…\n 5 Grapefruit        3       2.04 dress_images/images_high_res/cropped/grapefru…\n 6 Green            20      13.6  dress_images/images_high_res/cropped/green.jpg\n 7 Ocean blue       14       9.52 dress_images/images_high_res/cropped/ocean_bl…\n 8 Pink             29      19.7  dress_images/images_high_res/cropped/pink.jpg \n 9 Popsicle          4       2.72 dress_images/images_high_res/cropped/popsicle…\n10 Sunset orange    20      13.6  dress_images/images_high_res/cropped/sunset_o…\n11 Yellow           23      15.6  dress_images/images_high_res/cropped/yellow.j…\n\n\n\nallSongsMetadata <- \"raw_data/album_info_metadata_neutral.xlsx\"\nallSongsMetadata <- readxl::read_excel(allSongsMetadata, sheet = \"metadata\")\nsource(\"code/colour_palletts.r\")\nrawColorData <- data.frame(\n    colour = trimws(unlist(strsplit(allSongsMetadata$colour_MK, \";\"))),\n    meaning = trimws(unlist(strsplit(allSongsMetadata$colour_meaningMK, \";\")))\n) %>% filter(!is.na(colour) & !is.na(meaning))\n\ncolorSentimentScores <- rawColorData %>%\n    mutate(\n        meaning = trimws(meaning),  \n        score = case_when(\n            tolower(meaning) == \"positive\" ~ 1,\n            tolower(meaning) == \"neutral\" ~ 0.5,\n            tolower(meaning) == \"negative\" ~ 0,\n            TRUE ~ NA_real_\n        )\n    )\n\n## Calculate average sentiment for each individual color\nindividualColorSentiments <- colorSentimentScores %>%\n    group_by(colour) %>%\n    summarise(\n        avgSentiment = mean(score, na.rm = TRUE),\n        mentionCount = n()\n    ) %>%\n    ungroup()\n\nindividualColorSentiments$colourGroup <- colorGroups[individualColorSentiments$colour]\nindividualColorSentiments$colourHexColour <-sapply(individualColorSentiments$colour, \\(x) colorPaletteColours[[x]])\nindividualColorSentiments$colourGroupColour <-sapply(individualColorSentiments$colourGroup, \\(x) colorPaletteGroups[[x]])\n\nindividualColorSentiments\n\n# A tibble: 69 × 6\n   colour                avgSentiment mentionCount colourGroup   colourHexColour\n   <chr>                        <dbl>        <int> <chr>         <chr>          \n 1 amber                        0.5              1 yellows       #FFBF00        \n 2 aquamarine                   1                1 blues         #7FFFD4        \n 3 aurora borealis green        1                2 greens        #78E08F        \n 4 black                        0.5              9 blacks        #000000        \n 5 black and white              0.25             4 black and wh… #C0C0C0        \n 6 blackout                     1                1 blacks        #1A1A1A        \n 7 bleached                     0.5              1 whites        #F5F5DC        \n 8 blood monlit                 1                1 reds          #8A0303        \n 9 blood-soaked                 0                2 reds          #8B0000        \n10 blue                         0.409           22 blues         #0000FF        \n# ℹ 59 more rows\n# ℹ 1 more variable: colourGroupColour <chr>"
  },
  {
    "objectID": "viz.html#the-most-worn-looks",
    "href": "viz.html#the-most-worn-looks",
    "title": "2  Visualizing surprise song outfits",
    "section": "The most worn looks",
    "text": "The most worn looks\n\n## barchart\nggplot(outfits, aes(x = reorder(DressName, -n), y = n, fill = DressName)) +\n    geom_bar(stat = \"identity\", width = 0.8) +  \n    geom_image(\n        aes(image = imagePath, y = n),  \n        size = 0.15,                    \n        by = \"height\"                    \n    ) +\n    geom_text(\n        aes(y = n + 3.8, label = paste0(n, \"\\n(\", round(percentage, 1), \"%)\")),  \n        vjust = 0,  \n        color = \"black\",\n        size = 4\n    ) +\n    scale_fill_manual(values = colorPaletteDresses) +\n    theme_minimal() +\n    labs(title = \"\", x = \"\", y = \"\") +\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1, size = 14),\n        axis.text.y = element_text(size = 14),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_blank(),\n        axis.title.y = element_blank(),\n        legend.position = \"none\"\n    ) + ylim(0, 35)"
  },
  {
    "objectID": "outfit_transitions.html#a-chi2-test-for-the-transition-counts",
    "href": "outfit_transitions.html#a-chi2-test-for-the-transition-counts",
    "title": "3  Are the surprise song outfits random?",
    "section": "3.1 A \\(\\chi^2\\)-test for the transition counts",
    "text": "3.1 A \\(\\chi^2\\)-test for the transition counts\nLikely, the first standard hypothesis test you think of for count/contingency data is the \\(\\chi^2\\)-test (or the chi-squared test). Essentially, this works by testing for equal transition rates (if the outfit choices were completely random we’d expect equal numbers of transitions between the outfits); Slightly more formally,\n\\(H_0 = \\text{row outfits independent of column outfits}\\) vs. \\(H_1 = \\text{row outfits not independent of column outfits}\\).\n\n## first leg\nfirst_leg |> transitions() |> chisq.test()\n\n\n    Pearson's Chi-squared test\n\ndata:  transitions(first_leg)\nX-squared = 10.259, df = 9, p-value = 0.33\n\n## europe leg\nmid_leg |> transitions() |> chisq.test()\n\n\n    Pearson's Chi-squared test\n\ndata:  transitions(mid_leg)\nX-squared = 19.554, df = 4, p-value = 0.0006115\n\n## final leg\nfinal_leg |> transitions() |> chisq.test()\n\n\n    Pearson's Chi-squared test\n\ndata:  transitions(final_leg)\nX-squared = 17.337, df = 16, p-value = 0.3641\n\n\n\n\n\n\nTable 3.1: Summary of the chi-squared tests on the transition matricies for each leg of the Eras tour.\n\n\n\nChi-squared statistic\nDegrees of freedom\np-vlaue\n\n\n\n\nFirst Leg\n10.259\n9\n0.330\n\n\nEuropean Leg\n19.554\n4\n0.001\n\n\nFinal Leg\n17.337\n16\n0.364\n\n\n\n\n\n\nTherefore, if our \\(\\chi^2\\) assumptions were met we might infer that there’s some evidence against the outfits for the European leg being random.\n\n\n\n\n\nChi-squared distribution under the NULL hypothesis for each leg along with the observed chi-squared statistic in purple."
  },
  {
    "objectID": "outfit_transitions.html#a-randomisation-test",
    "href": "outfit_transitions.html#a-randomisation-test",
    "title": "3  Are the surprise song outfits random?",
    "section": "3.2 A randomisation test",
    "text": "3.2 A randomisation test\nIf we’re not happy that our parametric assumptions are met then we can (often) fall back on simple resampling methods; basically simulating what would happen under chance alone and then comparing how our observed situation stack up!\nTo begin with let’s use the \\(\\chi^2\\)-squared statistic to represent the transition matrix we observed for each leg (it is a valid metric comparing between what we expected under independence and what we observed). By using a randomisation test we can build up a sampling distribution of this chosen metric that represent what would happen under chance alone (i.e., without any assumptions about the shape of this distribution). Our observed statistics in this case are given in the first column of Table 3.1.\n\n## create a function for the randomisation test using chi-sq\n## on the transition matrix, using a for loop just bc\n\nrandomisation <- function(data, nreps = 1000, seed = 1984){\n  sampling_dist <- numeric(nreps)\n  set.seed(seed) \n  for (i in 1:nreps) {\n   sampling_dist[i] <- suppressWarnings(sample(data) |> \n                                          transitions() |> \n                                          chisq.test())$statistic\n  }\nreturn(sampling_dist)\n}\n\nCalculating a p-value (note they’re all pretty much the same as above!).\n\n## first leg\nnull_first <- randomisation(first_leg)\nmean(null_first >= (first_leg |> transitions() |> chisq.test())$statistic)\n\n[1] 0.336\n\n## European leg\nnull_mid <- randomisation(mid_leg)\nmean(null_mid >= (mid_leg |> transitions() |> chisq.test())$statistic)\n\n[1] 0.001\n\n## Final leg\nnull_final <- randomisation(final_leg)\nmean(null_final >= (final_leg |> transitions() |> chisq.test())$statistic)\n\n[1] 0.322\n\n\n\n\n\n\n\nSampling distribution of the test statistic (the chi-squared statistic) under the NULL hypothesis for each leg along with the observed test statistic in purple.\n\n\n\n\nBut, we can actually use any metric we like in a randomisation test! For our example, the \\(\\chi^2\\) is a nice (distance) statistic because it considers all the transitions, but if we were particularly interested in, say, a particular transition (e.g., Yellow \\(\\rightarrow\\) Pink for the first leg) we could look at those instead.\n\\(H_0 = \\text{A particular transition occured at random}\\)\nvs. \n\\(H_1 = \\text{A particular transition occured fewer or more times than expected}\\).\n[Note: than expected means than was expected under chance alone.]\n\n## create a new function for the randomisation test using the \n## numbers of a particular transition (from --> to)\n\nrandomisation <- function(data, from = \"Yellow\", to = \"Pink\", \n                          nreps = 1000, seed = 1984){\n  sampling_dist <- numeric(nreps)\n  set.seed(seed) \n  for (i in 1:nreps) {\n   sampling_dist[i] <- (sample(data) |> transitions())[from, to]\n  }\nreturn(sampling_dist)\n}\n\nCalculating a two-sided p-value.\n\n## first leg, Yellow --> Pink (default)\nnull_first <- randomisation(first_leg)\nobs_first <- (first_leg |> transitions())[\"Yellow\", \"Pink\"]\nmean(abs(null_first - mean(null_first)) >= abs(obs_first - mean(null_first)))\n\n[1] 0.199\n\n## European leg, Sunset orange --> Flamingo pink\nnull_mid <- randomisation(mid_leg, from = \"Sunset orange\", to = \"Flamingo pink\")\nobs_mid <- (mid_leg |> transitions())[\"Sunset orange\", \"Flamingo pink\"]\nmean(abs(null_mid - mean(null_mid)) >= abs(obs_mid - mean(null_mid)))\n\n[1] 0.766\n\n## Final leg, Blurple --> Blurple\nnull_final <- randomisation(final_leg, from = \"Blurple\", to = \"Blurple\")\nobs_final <- (final_leg |> transitions())[\"Blurple\", \"Blurple\"]\nmean(abs(null_final - mean(null_final)) >= abs(obs_final - mean(null_final)))\n\n[1] 0.644\n\n\n\n\n\n\n\nSampling distribution of the test statistic (the number of times a particular transition occured) under the NULL hypothesis for each leg along with the observed test statistic in purple.\n\n\n\n\nIn each case, no evidence to suggest we see the particular transitions more or less frequently than would be expected under the NULL hypothesis of chance alone. (Note the transitions were chosen arbitrarily)"
  },
  {
    "objectID": "outfit_transitions.html#a-likelihood-ratio-test",
    "href": "outfit_transitions.html#a-likelihood-ratio-test",
    "title": "3  Are the surprise song outfits random?",
    "section": "3.3 A likelihood ratio test",
    "text": "3.3 A likelihood ratio test\nWhat about using a model based approach? If the outfits were random (given the choices) then we’d expect each to occur independently of one another (i.e., the chance of one outfit is independent of any other).\nLet’s consider the first leg, defining the events mathematically we let \\(\\{X_1, X_2, \\ldots, X_n\\}\\) be the outfits taking values in \\(\\{\\text{Blue}, \\text{Green}, \\text{Pink}, \\text{Yellow}\\}\\) (i.e., four possible categories).\nIf the outfits were independent then we can write the likelihood as\n\\[L_0(p; x) = \\prod_{t=1}^{n} P(X_t = x_t) = \\prod_{j=1}^{4} p_j^{n_j}\\].\nHere \\(p_j\\) is the probability of observing category \\(j\\), \\(n_j\\) is the number of times category \\(j\\) appears from \\(t=2\\) to \\(n\\), and \\(\\sum_{j=1}^{k} p_j = 1\\). The log-likelihood is therefore \\[\\log L_0(p;x) = \\sum_{t=2}^{n} \\log p_{x_t} = \\sum_{j=1}^{4} n_j \\log p_j\\].\nCalculating this in R step-by-step\n\nn <- length(first_leg)\nn\n\n[1] 81\n\nk <- length(unique(first_leg))\nk\n\n[1] 4\n\nchain <- as.factor(first_leg)\nchain\n\n [1] Pink   Green  Pink   Green  Green  Pink   Yellow Pink   Green  Yellow\n[11] Pink   Green  Green  Pink   Yellow Pink   Green  Yellow Pink   Yellow\n[21] Green  Yellow Green  Pink   Pink   Green  Yellow Pink   Green  Yellow\n[31] Pink   Yellow Yellow Pink   Green  Pink   Pink   Yellow Yellow Pink  \n[41] Green  Pink   Pink   Yellow Pink   Pink   Pink   Pink   Yellow Green \n[51] Blue   Blue   Pink   Green  Yellow Blue   Pink   Yellow Yellow Blue  \n[61] Green  Blue   Yellow Green  Blue   Yellow Pink   Green  Yellow Pink  \n[71] Blue   Pink   Blue   Yellow Green  Yellow Green  Pink   Pink   Yellow\n[81] Blue  \nLevels: Blue Green Pink Yellow\n\np_indep <- table(chain) / n\np_indep ## independent probabilities\n\nchain\n     Blue     Green      Pink    Yellow \n0.1111111 0.2469136 0.3580247 0.2839506 \n\np_indep[as.integer(chain)] ## probabilities of each element as they occur\n\nchain\n     Pink     Green      Pink     Green     Green      Pink    Yellow      Pink \n0.3580247 0.2469136 0.3580247 0.2469136 0.2469136 0.3580247 0.2839506 0.3580247 \n    Green    Yellow      Pink     Green     Green      Pink    Yellow      Pink \n0.2469136 0.2839506 0.3580247 0.2469136 0.2469136 0.3580247 0.2839506 0.3580247 \n    Green    Yellow      Pink    Yellow     Green    Yellow     Green      Pink \n0.2469136 0.2839506 0.3580247 0.2839506 0.2469136 0.2839506 0.2469136 0.3580247 \n     Pink     Green    Yellow      Pink     Green    Yellow      Pink    Yellow \n0.3580247 0.2469136 0.2839506 0.3580247 0.2469136 0.2839506 0.3580247 0.2839506 \n   Yellow      Pink     Green      Pink      Pink    Yellow    Yellow      Pink \n0.2839506 0.3580247 0.2469136 0.3580247 0.3580247 0.2839506 0.2839506 0.3580247 \n    Green      Pink      Pink    Yellow      Pink      Pink      Pink      Pink \n0.2469136 0.3580247 0.3580247 0.2839506 0.3580247 0.3580247 0.3580247 0.3580247 \n   Yellow     Green      Blue      Blue      Pink     Green    Yellow      Blue \n0.2839506 0.2469136 0.1111111 0.1111111 0.3580247 0.2469136 0.2839506 0.1111111 \n     Pink    Yellow    Yellow      Blue     Green      Blue    Yellow     Green \n0.3580247 0.2839506 0.2839506 0.1111111 0.2469136 0.1111111 0.2839506 0.2469136 \n     Blue    Yellow      Pink     Green    Yellow      Pink      Blue      Pink \n0.1111111 0.2839506 0.3580247 0.2469136 0.2839506 0.3580247 0.1111111 0.3580247 \n     Blue    Yellow     Green    Yellow     Green      Pink      Pink    Yellow \n0.1111111 0.2839506 0.2469136 0.2839506 0.2469136 0.3580247 0.3580247 0.2839506 \n     Blue \n0.1111111 \n\np_indep[as.integer(chain)] |> log() ## log probabilities of each element as they occur\n\nchain\n     Pink     Green      Pink     Green     Green      Pink    Yellow      Pink \n-1.027153 -1.398717 -1.027153 -1.398717 -1.398717 -1.027153 -1.258955 -1.027153 \n    Green    Yellow      Pink     Green     Green      Pink    Yellow      Pink \n-1.398717 -1.258955 -1.027153 -1.398717 -1.398717 -1.027153 -1.258955 -1.027153 \n    Green    Yellow      Pink    Yellow     Green    Yellow     Green      Pink \n-1.398717 -1.258955 -1.027153 -1.258955 -1.398717 -1.258955 -1.398717 -1.027153 \n     Pink     Green    Yellow      Pink     Green    Yellow      Pink    Yellow \n-1.027153 -1.398717 -1.258955 -1.027153 -1.398717 -1.258955 -1.027153 -1.258955 \n   Yellow      Pink     Green      Pink      Pink    Yellow    Yellow      Pink \n-1.258955 -1.027153 -1.398717 -1.027153 -1.027153 -1.258955 -1.258955 -1.027153 \n    Green      Pink      Pink    Yellow      Pink      Pink      Pink      Pink \n-1.398717 -1.027153 -1.027153 -1.258955 -1.027153 -1.027153 -1.027153 -1.027153 \n   Yellow     Green      Blue      Blue      Pink     Green    Yellow      Blue \n-1.258955 -1.398717 -2.197225 -2.197225 -1.027153 -1.398717 -1.258955 -2.197225 \n     Pink    Yellow    Yellow      Blue     Green      Blue    Yellow     Green \n-1.027153 -1.258955 -1.258955 -2.197225 -1.398717 -2.197225 -1.258955 -1.398717 \n     Blue    Yellow      Pink     Green    Yellow      Pink      Blue      Pink \n-2.197225 -1.258955 -1.027153 -1.398717 -1.258955 -1.027153 -2.197225 -1.027153 \n     Blue    Yellow     Green    Yellow     Green      Pink      Pink    Yellow \n-2.197225 -1.258955 -1.398717 -1.258955 -1.398717 -1.027153 -1.027153 -1.258955 \n     Blue \n-2.197225 \n\nll0 <- p_indep[as.integer(chain)] |> log() |> sum() ## log likelihood\nll0\n\n[1] -106.4928\n\n\nNow, what about the likelihood if we assume the sequence of outfits is a first-order Markov chain (i.e., the current outfit \\(X_t\\) depends on the previous one \\(X_{t-1}\\)):\n\\[P(X_t = x_t \\mid X_{t-1} = x_{t-1}) = P_{x_{t-1}, x_t}.\\]\nHere \\(P_{i,j}\\) is the probability of transitioning from state \\(i\\) to state \\(j\\), again with \\(\\sum_{j=1}^{k} P_{i,j} = 1 \\quad \\text{for all } i\\). We can write the likelihood as\n\\[L_1(p;x_t|x_{t-1}) = \\prod_{t=2}^{n} P(X_t = x_t \\mid X_{t-1} = x_{t-1}) = \\prod_{i=1}^{k} \\prod_{j=1}^{k} P_{i,j}^{N_{i,j}}\\]\nWhere \\(N_{i,j}\\) is the number of transitions from state \\(i\\) to state \\(j\\). The log-likelihood is then\n\\[\\log(L_1(p;x_t|x_{t-1})) = \\sum_{t=2}^{n} \\log (P_{x_{t-1}, x_t}) = \\sum_{i=1}^{k} \\sum_{j=1}^{k} N_{i,j} \\log (P_{i,j})\\]\nCalculating this in R step-by-step\n\n## transition probability matrix\ntm <- prop.table(transitions(first_leg), 1) ## over rows\ntm\n\n        \n               Blue      Green       Pink     Yellow\n  Blue   0.12500000 0.12500000 0.37500000 0.37500000\n  Green  0.15000000 0.10000000 0.35000000 0.40000000\n  Pink   0.06896552 0.37931034 0.24137931 0.31034483\n  Yellow 0.13043478 0.26086957 0.47826087 0.13043478\n\n## using a for loop\nll1 <- 0 ## initialise\nfor(i in 2:n){\n  lli <- log(tm[chain[i-1], chain[i]]) ## element of tm\n  ll1 <- ll1 + lli\n}\nll1 ## log likelihood assuming a first-order Markov chain\n\n[1] -99.9088\n\n## we can benchmark using the markovchain package \nmarkovchain::markovchainFit(data = first_leg, method = \"mle\")$logLikelihood\n\n[1] -99.9088\n\n\nConstruction a likelihood ratio test statistic\n\\[\\Lambda = 2 \\left( \\log(L_1(p;x_t|x_{t-1}))  - \\log(L_0(p; x)) \\right)\\]\nUnder the NULL hypothesis \\(H_0\\), the test statistic \\(\\Lambda\\) asymptotically follows a \\(\\chi^2\\) distribution with degrees of freedom \\(\\text{df} = (k - 1)^2\\).\nIn R\n\ndelta <- 2 * (ll1 - ll0)\ndf <- (k - 1)^2\np_val <- pchisq(delta, df, lower.tail = FALSE)\n\nNo evidence against the outfits being independent.\n\n\n\n\n\nDistribution of the test statistic under the NULL hypothesis, the observed value shown in purple.\n\n\n\n\nSo, let’s make a function.\n\nlrt <- function(x, plot = FALSE){\n  ## under H0\n  n <- length(x)\n  k <- length(unique(x))\n  chain <- as.factor(x)\n  p_indep <- table(chain) / n\n  ll0 <- p_indep[as.integer(chain)] |> log() |> sum() \n  ## first-order Markov\n  tm <- prop.table(transitions(x), 1) \n  ll1 <- 0 \n  for(i in 2:n){\n    lli <- log(tm[chain[i-1], chain[i]]) \n    ll1 <- ll1 + lli\n  }\n  ## test statistic\n  delta <- 2 * (ll1 - ll0)\n  df <- (k - 1)^2\n  p_val <- pchisq(delta, df, lower.tail = FALSE)\n  if(plot){\n    chi <- data.frame(x = seq(0, 30, length.out = 100))\n    chi$density <- dchisq(chi$x, df = df)\n    chi %>%\n      ggplot(aes(x = x, y = density)) +\n      geom_line(linewidth = 2) +\n      geom_vline(aes(xintercept = delta), linetype = \"dashed\", color = \"purple\") +\n      labs(title = \"\",x = \"\", y = \"\") + theme_bw() -> p\n    print(p)\n  }\n  ## info to return\n  return(list(\"ll0\" = ll0,\n              \"ll1\" = ll1,\n              \"delta\" = delta,\n              \"df\" = df,\n              \"p.val\" = p_val))\n}\n\nlrt(first_leg)\n\n$ll0\n[1] -106.4928\n\n$ll1\n[1] -99.9088\n\n$delta\n[1] 13.16793\n\n$df\n[1] 9\n\n$p.val\n[1] 0.1551535\n\nlrt(mid_leg, plot = TRUE)\n\n\n\n\n$ll0\n[1] -52.30575\n\n$ll1\n[1] -39.26825\n\n$delta\n[1] 26.075\n\n$df\n[1] 4\n\n$p.val\n[1] 3.056156e-05\n\nlrt(final_leg, plot = TRUE)\n\n\n\n\n$ll0\n[1] -26.26847\n\n$ll1\n[1] -14.04639\n\n$delta\n[1] 24.44415\n\n$df\n[1] 16\n\n$p.val\n[1] 0.08024261\n\n\nFirst order Markov chain?\nSo, might we believe that for the European leg of her tour Swift’s outfits weren’t random and perhaps what she wore one night depended on her outfit the previous night (i.e., in stats speak followed a first-order Markov chain)?\n\n\n\n\n\n\nNote\n\n\n\nBasically, the first-order Markov property is that the future state of a system depends only on its current state and is independent of its past history.\n\n\n\nrequire(markovchain)\nverifyMarkovProperty(mid_leg) ## no evidence against the Markov property p-value 0.834 (~likely a Markov chain?)\n\nTesting markovianity property on given data sequence\nChi - square statistic is: 7.339583 \nDegrees of freedom are: 12 \nAnd corresponding p-value is: 0.8343811 \n\nmarkovchainFit(data = mid_leg, method = \"mle\") ## as above but with ses :)\n\n$estimate\nMLE Fit \n A  3 - dimensional discrete Markov Chain defined by the following states: \n Flamingo pink, Ocean blue, Sunset orange \n The transition matrix  (by rows)  is defined as follows: \n              Flamingo pink Ocean blue Sunset orange\nFlamingo pink    0.06666667  0.2666667     0.6666667\nOcean blue       0.57142857  0.0000000     0.4285714\nSunset orange    0.27777778  0.5555556     0.1666667\n\n\n$standardError\n              Flamingo pink Ocean blue Sunset orange\nFlamingo pink    0.06666667  0.1333333    0.21081851\nOcean blue       0.20203051  0.0000000    0.17496355\nSunset orange    0.12422600  0.1756821    0.09622504\n\n$confidenceLevel\n[1] 0.95\n\n$lowerEndpointMatrix\n              Flamingo pink  Ocean blue Sunset orange\nFlamingo pink    0.00000000 0.005338081    0.25346989\nOcean blue       0.17545597 0.000000000    0.08564909\nSunset orange    0.03429924 0.211224910    0.00000000\n\n$upperEndpointMatrix\n              Flamingo pink Ocean blue Sunset orange\nFlamingo pink     0.1973310  0.5279953     1.0000000\nOcean blue        0.9674012  0.0000000     0.7714938\nSunset orange     0.5212563  0.8998862     0.3552643\n\n$logLikelihood\n[1] -39.26825\n\n\nWhat about 1st vs 2nd Markov Chain\n\n## Let's trick markovchain into doing this for us\n## by creating a \"first order\" chain which is actually of order 2\n\nsnap <- data.frame(current = mid_leg)\nsnap$future <- lead(snap$current, 1)\nsnap$past <- lag(snap$current, 1)\n\nsec_order <- snap |>\n  filter(!is.na(future) & !is.na(past)) %>%\n  tidyr::unite(\"y_current\", c(\"past\", \"current\"), remove = FALSE) |>\n  mutate(y_next = lead(y_current, 1),\n         y_previous = lag(y_current, 1))\n\nll1 <- markovchainFit(data = mid_leg, method = \"mle\")$logLikelihood\nll1\n\n[1] -39.26825\n\nll2 <- markovchainFit(data = sec_order$y_current, method = \"mle\")$logLikelihood\nll2 ## eyeballing this, looks pretty similar to 1st order\n\n[1] -32.29189\n\n\nFor fun let’s also calculate the 2nd order Markov Chain likelihood manually.\n\n## function to calculate the log likelihood assuming a second-order Markov chain\nll2 <- function(x){\n  n <- length(x)\n  k <- length(unique(x))\n  chain <- as.factor(x)\n  ## Initialize 3D transition count array\n  counts <- array(0, dim = c(k, k, k))\n  int <- as.integer(chain)\n  for (t in 3:n) {\n    a <- int[t - 2]\n    b <- int[t - 1]\n    c <- int[t]\n    counts[a, b, c] <- counts[a, b, c] + 1\n    }\n  ## Calculate conditional probabilities\n  probs <- counts\n  for (a in 1:k) {\n    for (b in 1:k) {\n      total <- sum(counts[a, b, ])\n    if (total > 0) {probs[a, b, ] <- counts[a, b, ] / total}\n      }\n    }\n  ll <- 0\n  for (t in 3:n) {\n    a <- int[t - 2]\n    b <- int[t - 1]\n    c <- int[t]\n    p <- probs[a, b, c]\n    if (p > 0) {ll <- ll + log(p)}\n  }\n  return(ll)\n}\n## 2nd order Markov Chain log-likelihood\nll2(mid_leg)\n\n[1] -32.88436"
  },
  {
    "objectID": "colour_sentiments.html",
    "href": "colour_sentiments.html",
    "title": "4  Colour Sentiments",
    "section": "",
    "text": "NULL\n\n\n\n## Beta regression basic\nmod <- betareg::betareg(avgSentiment ~ colourGroup, data = individualColorSentiments)\nmod |> summary()\n\n\nCall:\nbetareg::betareg(formula = avgSentiment ~ colourGroup, data = individualColorSentiments)\n\nRandomized quantile residuals:\n    Min      1Q  Median      3Q     Max \n-2.0770 -0.7386  0.0000  0.8865  2.2478 \n\nCoefficients (mu model with logit link):\n                    Estimate Std. Error z value Pr(>|z|)   \n(Intercept)         -0.06829    0.02886  -2.366  0.01796 * \ncolourGroupblacks    0.06829    0.03071   2.224  0.02614 * \ncolourGroupblues     0.06317    0.02954   2.138  0.03248 * \ncolourGroupcolorful  0.08829    0.03155   2.799  0.00513 **\ncolourGroupgreens    0.08436    0.03218   2.622  0.00874 **\ncolourGrouppurples   0.08239    0.03205   2.571  0.01015 * \ncolourGroupreds      0.06924    0.02947   2.350  0.01879 * \ncolourGroupwhites    0.06268    0.03029   2.069  0.03852 * \ncolourGroupyellows   0.07526    0.03042   2.474  0.01337 * \n\nPhi coefficients (phi model with identity link):\n      Estimate Std. Error z value Pr(>|z|)    \n(phi)     8450       2211   3.822 0.000132 ***\n\nExceedence parameter (extended-support xbetax model):\n        Estimate Std. Error z value Pr(>|z|)    \nLog(nu)   4.5563     0.2507   18.17   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 \n\nExceedence parameter nu: 95.2263\nType of estimator: ML (maximum likelihood)\nLog-likelihood: -56.72 on 11 Df\nNumber of iterations in BFGS optimization: 679 \n\nrequire(mgcv)\ngam <- gam(avgSentiment ~ colourGroup, family = betar(link=\"logit\"), data = individualColorSentiments)\nsummary(gam)\n\n\nFamily: Beta regression(0.114) \nLink function: logit \n\nFormula:\navgSentiment ~ colourGroup\n\nParametric coefficients:\n                    Estimate Std. Error z value Pr(>|z|)\n(Intercept)         -0.06247    1.41004  -0.044    0.965\ncolourGroupblacks    0.06247    1.54475   0.040    0.968\ncolourGroupblues    -0.10132    1.47240  -0.069    0.945\ncolourGroupcolorful  0.94004    1.47565   0.637    0.524\ncolourGroupgreens    0.75018    1.53214   0.490    0.624\ncolourGrouppurples   0.72811    1.53282   0.475    0.635\ncolourGroupreds      0.15321    1.44663   0.106    0.916\ncolourGroupwhites   -0.30113    1.54076  -0.195    0.845\ncolourGroupyellows   0.28614    1.48549   0.193    0.847\n\n\nR-sq.(adj) =  -0.0154   Deviance explained = -0.308%\n-REML = -1017.9  Scale est. = 1         n = 69\n\nnew.y <- predict(gam, se.fit = TRUE, type=\"response\")\n\n## correspondance analysis\n\ntable(colorSentimentScores$colour, colorSentimentScores$meaning)\n\n                       \n                        negative neutral positive\n  amber                        0       1        0\n  aquamarine                   0       0        1\n  aurora borealis green        0       0        2\n  black                        2       5        2\n  black and white              2       2        0\n  blackout                     0       0        1\n  bleached                     0       1        0\n  blood monlit                 0       0        1\n  blood-soaked                 2       0        0\n  blue                        10       6        6\n  blues                        3       0        0\n  bluest                       2       0        0\n  bronze                       0       1        0\n  burgundy                     0       1        0\n  burning red                  1       0        0\n  cherry                       0       0        1\n  colour                       0       0        2\n  colours                      0       0        4\n  crimson                      0       0        1\n  crimson clover               1       0        0\n  dark gray                    0       1        0\n  darkest gray                 1       0        0\n  deep blue                    1       0        0\n  deep brown                   0       0        1\n  evergreen                    0       0        1\n  flamingo pink                0       0        1\n  gold                         0       4        4\n  golden                       0       1       11\n  gray                        11       1        2\n  green                        0       1        5\n  greige                       1       0        0\n  hospital gray                1       0        0\n  indigo                       0       0        1\n  key lime green               0       1        0\n  lavender                     0       0        2\n  light pink                   0       0        1\n  lilac                        0       1        0\n  maroon                       0       2        0\n  moonstone                    0       0        1\n  neon                         0       0        2\n  ocean blue                   0       0        1\n  ocean wave blues             1       0        0\n  opal                         0       1        0\n  orange                       0       1        0\n  pale blue                    0       0        1\n  pastel                       0       1        0\n  pink                         0       0        1\n  plaid                        0       2        0\n  purple-pink                  0       0        1\n  rainbow                      0       0        1\n  red                          6       4        6\n  redhaired                    0       1        0\n  redneck                      1       0        0\n  rose                         0       1        0\n  rose golden                  0       1        0\n  rosy                         0       0        1\n  sapphire                     1       0        0\n  scarlet                      2       2        0\n  scarlet maroon               1       0        0\n  screaming colour             0       0        1\n  silver                       0       1        0\n  snow white                   0       1        0\n  stained glass                1       0        0\n  tangerine                    0       0        1\n  teal                         0       1        0\n  ultraviolet                  0       0        1\n  violets                      1       0        0\n  white                        1       9        3\n  wine-stained                 1       0        0\n\ncolorSentimentScores$colourGroup <- colorGroups[colorSentimentScores$colour]\ncols.df <- as.data.frame.matrix(table(colorSentimentScores$colourGroup, colorSentimentScores$meaning))\ncols.df\n\n                negative neutral positive\nblack and white        2       2        0\nblacks                 3       7        3\nblues                 18       7       10\ncolorful               1       3       11\ngreens                 0       3        8\npurples                1       1        4\nreds                  15      11       13\nwhites                13      12        5\nyellows                1       9       17\n\nchisq.test(cols.df)\n\n\n    Pearson's Chi-squared test\n\ndata:  cols.df\nX-squared = 47.661, df = 16, p-value = 5.369e-05\n\ncoa <- ade4::dudi.coa(cols.df, scannf = FALSE, nf = 2)\n\nlibrary(factoextra) \nfviz_ca_biplot(coa, repel = TRUE, col.col = \"brown\", col.row = \"purple\",\n               labelsize = 5, pointsize = 5) + ggtitle(\"\") +\n  theme(legend.text = element_text(size = 25),\n        axis.title.x.bottom = element_text(size = 15),\n        axis.title.y.left = element_text(size = 15),\n        axis.text = element_text(size = 15)) +\n  ylim(c(-0.5,0.5))"
  },
  {
    "objectID": "colour_sentiments.html#beta-regression",
    "href": "colour_sentiments.html#beta-regression",
    "title": "4  Colour Sentiments",
    "section": "4.1 Beta regression?",
    "text": "4.1 Beta regression?\n\n## Beta regression basic\nmod <- betareg::betareg(avgSentiment ~ colourGroup, data = individualColorSentiments)\nmod |> summary()\n\n\nCall:\nbetareg::betareg(formula = avgSentiment ~ colourGroup, data = individualColorSentiments)\n\nRandomized quantile residuals:\n    Min      1Q  Median      3Q     Max \n-2.0770 -0.7386  0.0000  0.8865  2.2478 \n\nCoefficients (mu model with logit link):\n                    Estimate Std. Error z value Pr(>|z|)   \n(Intercept)         -0.06829    0.02886  -2.366  0.01796 * \ncolourGroupblacks    0.06829    0.03071   2.224  0.02614 * \ncolourGroupblues     0.06317    0.02954   2.138  0.03248 * \ncolourGroupcolorful  0.08829    0.03155   2.799  0.00513 **\ncolourGroupgreens    0.08436    0.03218   2.622  0.00874 **\ncolourGrouppurples   0.08239    0.03205   2.571  0.01015 * \ncolourGroupreds      0.06924    0.02947   2.350  0.01879 * \ncolourGroupwhites    0.06268    0.03029   2.069  0.03852 * \ncolourGroupyellows   0.07526    0.03042   2.474  0.01337 * \n\nPhi coefficients (phi model with identity link):\n      Estimate Std. Error z value Pr(>|z|)    \n(phi)     8450       2211   3.822 0.000132 ***\n\nExceedence parameter (extended-support xbetax model):\n        Estimate Std. Error z value Pr(>|z|)    \nLog(nu)   4.5563     0.2507   18.17   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 \n\nExceedence parameter nu: 95.2263\nType of estimator: ML (maximum likelihood)\nLog-likelihood: -56.72 on 11 Df\nNumber of iterations in BFGS optimization: 679 \n\nrequire(mgcv)\ngam <- gam(avgSentiment ~ colourGroup, family = betar(link=\"logit\"), data = individualColorSentiments)\nsummary(gam)\n\n\nFamily: Beta regression(0.114) \nLink function: logit \n\nFormula:\navgSentiment ~ colourGroup\n\nParametric coefficients:\n                    Estimate Std. Error z value Pr(>|z|)\n(Intercept)         -0.06247    1.41004  -0.044    0.965\ncolourGroupblacks    0.06247    1.54475   0.040    0.968\ncolourGroupblues    -0.10132    1.47240  -0.069    0.945\ncolourGroupcolorful  0.94004    1.47565   0.637    0.524\ncolourGroupgreens    0.75018    1.53214   0.490    0.624\ncolourGrouppurples   0.72811    1.53282   0.475    0.635\ncolourGroupreds      0.15321    1.44663   0.106    0.916\ncolourGroupwhites   -0.30113    1.54076  -0.195    0.845\ncolourGroupyellows   0.28614    1.48549   0.193    0.847\n\n\nR-sq.(adj) =  -0.0154   Deviance explained = -0.308%\n-REML = -1017.9  Scale est. = 1         n = 69\n\nnew.y <- predict(gam, se.fit = TRUE, type=\"response\")"
  },
  {
    "objectID": "colour_sentiments.html#correspondance-analysis",
    "href": "colour_sentiments.html#correspondance-analysis",
    "title": "4  Colour Sentiments",
    "section": "4.1 Correspondance analysis",
    "text": "4.1 Correspondance analysis\n\ncolorSentimentScores$colourGroup <- colorGroups[colorSentimentScores$colour]\ncols.df <- as.data.frame.matrix(table(colorSentimentScores$colourGroup, colorSentimentScores$meaning))\ncols.df\n\n                negative neutral positive\nblack and white        2       2        0\nblacks                 3       7        3\nblues                 18       7       10\ncolorful               1       3       11\ngreens                 0       3        8\npurples                1       1        4\nreds                  15      11       13\nwhites                13      12        5\nyellows                1       9       17\n\nchi <- chisq.test(cols.df)\nchi\n\n\n    Pearson's Chi-squared test\n\ndata:  cols.df\nX-squared = 47.661, df = 16, p-value = 5.369e-05\n\nlibrary(corrplot)\ncorrplot(chi$residuals, is.corr = FALSE, cl.pos = FALSE)\n\n\n\n## coa <- ade4::dudi.coa(cols.df, scannf = FALSE, nf = 2)\ncoa <- FactoMineR::CA(cols.df)\n\n\n\nlibrary(factoextra) \n## row/colour contribution asymmetric biplot \nfviz_ca_biplot(coa, repel = TRUE, col.col = \"brown\", col.row = \"purple\",\n               labelsize = 5, pointsize = 5, map = \"rowprincipal\") + ggtitle(\"\") +\n  theme_void()\n\n\n\n## If the angle between two arrows is acute, then their is a strong association between the corresponding row and column.\n\n# Dimension description\nres.desc <- FactoMineR::dimdesc(coa, axes = c(1,2))\n# Description of dimension 1 by row points\nres.desc[[1]]$row\n\n                     coord\ngreens          -0.7643240\ncolorful        -0.6968777\nyellows         -0.5975927\npurples         -0.4987625\nblacks           0.1313584\nreds             0.1736515\nblues            0.3808608\nwhites           0.4418876\nblack and white  0.7303704\n\n# Description of dimension 1 by column points\nres.desc[[1]]$col\n\n               coord\npositive -0.52031114\nneutral   0.07774606\nnegative  0.60492700\n\n# Description of dimension 2 by row points\nres.desc[[2]]$row\n\n                      coord\nblues           -0.27284216\npurples         -0.24798828\ncolorful        -0.15318495\nreds            -0.07061839\ngreens           0.01315577\nyellows          0.12702125\nwhites           0.15722641\nblack and white  0.34361934\nblacks           0.49413385\n\n# Description of dimension 2 by column points\nres.desc[[2]]$col\n\n              coord\nnegative -0.1746621\npositive -0.1170984\nneutral   0.3226498"
  },
  {
    "objectID": "viz.html#surprise-song-color-groups",
    "href": "viz.html#surprise-song-color-groups",
    "title": "2  Visualizing surprise song outfits",
    "section": "Surprise song color groups",
    "text": "Surprise song color groups\n\nsurpriseSongsDressColours$groupName <- sapply(surpriseSongsDressColours$DressName, function(color) {\n  if (color %in% c(\"Pink\", \"Flamingo pink\")) return(\"reds\")\n  if (color %in% c(\"Green\")) return(\"greens\")\n  if(color %in% c(\"Yellow\", \"Sunset orange\")) return(\"yellows\")\n  if (color %in% c(\"Ocean blue\", \"Blue\", \"Blurple\")) return (\"blues\")\n  if (color %in% c(\"Popsicle\", \"Cotton candy\", \"Grapefruit\")) return (\"colorful\")\n  return(\"Neutral\")\n})\n\nsongs_with_single_color_group <- surpriseSongsDressColours %>%\n  group_by(`Song title`) %>%\n  summarize(\n    total_performances = n(),\n    unique_color_groups = n_distinct(groupName),\n    color_group = first(groupName) \n  ) %>%\n  filter(unique_color_groups == 1, total_performances > 1) %>%\n  arrange(desc(total_performances))\n\nsingle_color_performances <- surpriseSongsDressColours %>%\n    filter(`Song title` %in% songs_with_single_color_group$`Song title`)\n\n## pics\nblues <- paste(\"dress_images/images_high_res/cropped/\", c(\"blue\", \"ocean_blue\", \"blurple\"), \".jpg\", sep = \"\")\nreds <- paste(\"dress_images/images_high_res/cropped/\", c(\"pink\", \"flamingo_pink\"), \".jpg\", sep = \"\")\nyellows <- paste(\"dress_images/images_high_res/cropped/\", c(\"yellow\", \"sunset_orange\"), \".jpg\", sep = \"\")\n\ncoords <- circleProgressiveLayout(table(single_color_performances$groupName),\n                                  sizetype = 'area')\ncoords$id <- names(table(single_color_performances$groupName))\ndf.gg <- circleLayoutVertices(coords, npoints = 8, id = 4)\nsnames <- single_color_performances %>% select('Song title', groupName) %>%\n    group_by(`Song title`) %>% mutate(count = n()) %>% ungroup() |> unique()\nset.seed(1984) ## for jitter repel\nplot <- ggplot() + theme_void() +\n    ## blues\n    geom_polygon(data = df.gg[df.gg$id == \"blues\",], aes(x = x, y = y),\n                 fill = \"#0000FF\", alpha = 0.05) +\n    geom_text_repel(aes(x = coords$x[1], \n                        y = coords$y[1], \n                        label = snames$`Song title`[snames$groupName == \"blues\"]),\n                    col = \"#0000FF\", nudge_y = -1.1, nudge_x = 0.1, segment.color = NA,\n                    size = 1.5*snames$count[snames$groupName == \"blues\"], box.padding = 0.1,\n                    family = \"Gill Sans MT\") +\n    ## reds\n    geom_polygon(data = df.gg[df.gg$id == \"reds\",], aes(x = x, y = y),\n                 fill = \"#FF0000\", alpha = 0.05)  +\n    geom_text_repel(aes(x = coords$x[2], \n                        y = coords$y[2], \n                        label = snames$`Song title`[snames$groupName == \"reds\"]),\n                    col = \"#FF0000\", nudge_y = -0.9, nudge_x = 0.1, segment.color = NA,\n                    size = 1.5*snames$count[snames$groupName == \"reds\"], box.padding = 0.1,\n                    family = \"Gill Sans MT\") +\n    ## yellows\n    geom_polygon(data = df.gg[df.gg$id == \"yellows\",], aes(x = x, y = y),\n                 fill = \"#FFD700\", alpha = 0.05)  +\n    geom_text_repel(aes(x = coords$x[3], \n                        y = coords$y[3], \n                        label = snames$`Song title`[snames$groupName == \"yellows\"]),\n                    col = \"#FFD700\", nudge_y = 1.4, nudge_x = 0, segment.color = NA,\n                    size = 1.5*snames$count[snames$groupName == \"yellows\"], box.padding = 0.1,\n                    family = \"Gill Sans MT\")\n\n## image sizes relative to\n## table(single_color_performances$DressName, single_color_performances$groupName)\nset.seed(1984) ## for jitter repel\nggdraw() +\n    draw_plot(plot) +\n    draw_image(blues[1], -0.37, 0.23, scale = 0.5/3) +\n    draw_image(blues[2],  -0.2, 0.32, scale = 0.8/3) +\n    draw_image(blues[3],  -0.07, 0.26, scale = 0.4/3) +\n    draw_image(reds[1], 0.1, 0.27, scale = 0.8/3) +\n    draw_image(reds[2],  0.3, 0.33, scale = 0.7/3) +\n    draw_image(yellows[1], -0.1, -0.25, scale = 0.7/3) +\n    draw_image(yellows[2],  0.1, -0.3, scale = 1.1/3)"
  }
]